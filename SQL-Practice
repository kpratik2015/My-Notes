-- practice.sql --

SELECT * FROM EMPLOYEES;

SELECT EMPLOYEE_ID FROM EMPLOYEES;

SELECT FIRST_NAME ||' ' || LAST_NAME "FULL NAME" FROM EMPLOYEES;

SELECT SALARY FROM EMPLOYEES
WHERE SALARY BETWEEN 1000 AND 10000;

SELECT HIRE_DATE DT FROM EMPLOYEES ORDER BY DT DESC;

SELECT FIRST_NAME FN FROM EMPLOYEES WHERE FIRST_NAME LIKE 'A%' AND FIRST_NAME LIKE '%a'; /* You can't give alias for like */

SELECT * FROM EMP;

DESC EMP;

SELECT 34/67*44 FROM DUAL;

SELECT * FROM DEPT;
SELECT * FROM EMP;

/* manager's manager: */
SELECT E.EMPNO, E.ENAME, D.DNAME, E.MGR, M.ENAME, M.MGR, MM.ENAME 
FROM EMP E, DEPT D, EMP M, EMP MM 
WHERE E.DEPTNO = D.DEPTNO AND E.MGR = M.EMPNO AND M.MGR = MM.EMPNO AND MM.DEPTNO=D.DEPTNO;

/* SUBQUERY */
DROP TABLE DISK1;

CREATE TABLE DISK1(EMPNO NUMBER(3), ENAME VARCHAR2(15), SAL NUMBER(6,2));

CREATE TABLE DISK1 AS SELECT * FROM EMP;

DESC DISK1;

DESC EMP;

SELECT * FROM EMP;

SELECT DEPTNO FROM EMP GROUP BY DEPTNO;

SELECT AVG(SAL) FROM EMP;

-- SELECT DEPTNO FROM EMP WHERE SAL=(SELECT MAX(AVG(SAL)) AVG_SAL FROM EMP GROUP BY DEPTNO);
SELECT * FROM DEPT;

SELECT E.DEPTNO, D.DNAME, E.MAX_AVG_SAL 
FROM (
  SELECT DEPTNO, AVG(SAL) MAX_AVG_SAL 
  FROM EMP 
  GROUP BY DEPTNO 
  HAVING AVG(SAL) = (
    SELECT MAX(
      AVG(SAL)
    ) AVG_SAL 
    FROM EMP 
    GROUP BY DEPTNO
    )
) E, DEPT D 
WHERE D.DEPTNO = E.DEPTNO;

SELECT ROWNUM, DEPTNO FROM DEPT WHERE ROWNUM < 2;

SAVEPOINT A;

CREATE TABLE TABLEDUMMY AS SELECT * FROM EMP;

SAVEPOINT B;

DELETE FROM TABLEDUMMY;

DESC TABLEDUMMY;

ROLLBACK TO SAVEPOINT B;

DESC TABLEDUMMY;

SELECT * FROM TABLEDUMMY;

COMMIT;

create table sal_history ( eid number(4), hiredate date, sal number(9,2));
create table mgr_history ( eid number(4), manager number(4), sal number(9,2));
create table special_sal ( did number(4), sal number(9,2) );
create table hiredate_history_00 ( did number(4), hdate0 date );
create table hiredate_history_99 ( did number(4), hdate9 date );
create table hiredate_history ( did number(4), hdate date );
create table sales_source_data ( empno number(4), week_id number(1),
sales_mon number(5), sales_tue number(5), sales_wed number(5),
sales_thur number(5), sales_fri number(5));
insert into sales_source_data values (176, 6, 2000, 3000, 4000, 5000, 6000);
create table sales_info (empno number(4), wid number(2), sale number(5));

SELECT * FROM SAL_HISTORY;
SELECT * FROM MGR_HISTORY;

INSERT ALL
INTO sal_history VALUES(empid, hiredate, sal)
INTO mgr_history VALUES(empid, mgr, sal)
SELECT empno EMPID, hiredate HIREDATE,
sal SAL, mgr MGR
FROM emp
WHERE empno > 7698;

SELECT * FROM SAL_HISTORY;

SELECT * FROM MGR_HISTORY;

SHOW ALL;

SET SERVEROUTPUT ON;

SHOW SERVEROUTPUT;

BEGIN
DBMS_OUTPUT.PUT_LINE('Welcome');
END;
/

DECLARE
I NUMBER(4) := &I;
BEGIN
DBMS_OUTPUT.PUT_LINE(I);
END;
/

VARIABLE TEMP NUMBER

BEGIN
:TEMP:=10;
DBMS_OUTPUT.PUT_LINE(:TEMP);
END;
/

BEGIN
DBMS_OUTPUT.PUT_LINE(:TEMP);
END;
/

CREATE TABLE retired( ENAME VARCHAR2(100), EAGE NUMBER(3) );


DECLARE
TYPE MYTYPE IS RECORD(
NO NUMBER, NAME EMP.ENAME%TYPE);
MYREC MYTYPE;
BEGIN
SELECT EMPNO, ENAME INTO MYREC FROM EMP WHERE EMPNO = &EMPNO;
DBMS_OUTPUT.PUT_LINE(MYREC.NO || ' HIS NAME IS ' || MYREC.NAME);
END;
/

declare 
type mytype is table of number index by binary_integer;
myvar mytype;
begin
myvar(0) := 25;
myvar(1) := 23
dbms_output.put_line(myvar(0));
end;
/

DESC EMP;

SELECT * FROM DEPT;

DECLARE 
TYPE myemp IS RECORD (
  ENO NUMBER(10),
  EMPNAME VARCHAR2(100),
  DNO NUMBER(10),
  DEPTNAME VARCHAR(10)
);
TYPE emprec IS TABLE OF myemp INDEX BY BINARY_INTEGER;
erec emprec;
CURSOR mycur IS SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO;
i NUMBER := 0;
BEGIN
OPEN mycur;
LOOP
FETCH mycur into erec(i);
EXIT WHEN mycur%notfound;
i:=i+1;
END LOOP;
CLOSE mycur;
FOR j in 0..i-1
LOOP
DBMS_OUTPUT.PUT_LINE(erec(j).ENO || ' ' || erec(j).EMPNAME || ' ' || erec(j).DNO || ' ' || erec(j).DEPTNAME);
END LOOP;
END;
/

DECLARE 
vdeptrow dept%rowtype; 
CURSOR dept_cur RETURN dept%ROWTYPE IS SELECT * FROM dept WHERE deptno = &dno; 
BEGIN 
OPEN dept_cur; 
FETCH dept_cur INTO vdeptrow; 
DBMS_OUTPUT.PUT_LINE(vdeptrow.deptno||' '||vdeptrow.dname ||' '||vdeptrow.loc); 
CLOSE dept_cur; 
END;
/

-- TRIGGER

SELECT * FROM DEMO1;

SHOW SERVEROUTPUT;

SET SERVEROUTPUT ON;

CREATE OR REPLACE TRIGGER TRIGINS1 AFTER INSERT ON DEMO1 FOR EACH ROW
BEGIN
DBMS_OUTPUT.PUT_LINE('ROW INSERTED INTO DEMO1 TABLE');
END;
/

-- CREATE TABLE DEMO1 AS SELECT * FROM EMP;  -- To duplicate

SELECT * FROM DEMO1;

INSERT INTO DEMO1 VALUES(11, 'NEEL', 'ACTOR', 7839, '01-JAN-1950', 200, NULL, 50);

CREATE TABLE EMPSALUPPAT(EMPNO NUMBER(4), OSAL NUMBER(6,2), NSAL NUMBER(6,2), DOI DATE);

CREATE OR REPLACE TRIGGER TRIGSALUPPAT AFTER UPDATE OF SAL ON DEMO1 FOR EACH ROW
BEGIN
INSERT INTO EMPSALUPPAT VALUES(:OLD.EMPNO, :OLD.SAL, :NEW.SAL, SYSDATE);
END;
/

SELECT * FROM DEMO1;

UPDATE DEMO1 SET SAL=4000 WHERE EMPNO=2222;

SELECT * FROM DEMO1;

SELECT * FROM EMPSALUPPAT;


-- TRIGGER:

DESC USER_TRIGGERS;
DESC USER_SOURCE;

SELECT TEXT FROM USER_SOURCE WHERE NAME = 'TRIGSALUPPAT';
/*
Assignment: Create 3 tables - 
stock table: product id (primary key), product name, quantity (default 0)
purchase table: purchase id, product id (foreign key), purchase date and purchase quantity
sales table: bill date, product id, quantity 

Stock cannot go to negative (trigger)
Stock should be added for purchase or reduced for sell out
*/


CREATE TABLE STOCKPAT(
  PRODUCTID NUMBER(10) NOT NULL, 
  PRODUCTNAME VARCHAR2(100), 
  QUANTITY NUMBER(10) DEFAULT 0, 
  PRIMARY KEY(PRODUCTID)
);

DROP TABLE STOCKPAT;

CREATE TABLE PURCHASEPAT(
  PRODUCTID NUMBER(10) NOT NULL,
  PURCHASEID NUMBER(10) NOT NULL,
  PURCHASEDATE DATE,
  PURCHASEQUANTITY NUMBER(10),
  PRIMARY KEY(PURCHASEID),
  FOREIGN KEY (PRODUCTID) REFERENCES STOCKPAT(PRODUCTID)
);

DROP TABLE PURCHASEPAT;

CREATE TABLE SALESPAT(
  PRODUCTID NUMBER(10) NOT NULL,
  BILLDATE DATE,
  SALESQUANTITY NUMBER(10),
  PRIMARY KEY(PRODUCTID)
);

DROP TABLE SALESPAT;

SELECT * FROM STOCKPAT;
SELECT * FROM PURCHASEPAT;
SELECT * FROM SALESPAT;

VARIABLE PRODNAME VARCHAR2(100); -- only till session

BEGIN
:PRODNAME := 'smthng';
DBMS_OUTPUT.PUT_LINE(:PRODNAME || ' ss ');
END;
/

PRINT PRODNAME;

CREATE OR REPLACE TRIGGER TRIGSTOCKINSERT AFTER INSERT OR UPDATE ON PURCHASEPAT FOR EACH ROW
DECLARE
L_COUNT NUMBER(2);
CUSTPROD VARCHAR2(100);
BEGIN
SELECT COUNT(*) INTO L_COUNT FROM STOCKPAT WHERE PRODUCTID = :NEW.PRODUCTID;
IF L_COUNT > 0 THEN
UPDATE STOCKPAT SET QUANTITY=QUANTITY + :NEW.PURCHASEQUANTITY WHERE PRODUCTID=:NEW.PRODUCTID;
ELSE
--:PRODNAME := '&CUSTPROD';
--INSERT INTO STOCKPAT VALUES(:NEW.PRODUCTID, 'PRODNAME' , :NEW.PURCHASEQUANTITY);
raise_application_error(-20504,'There is no product with such productid');
END IF;
END;
/

CREATE OR REPLACE TRIGGER TRIGSTOCKDEL AFTER INSERT OR UPDATE ON SALESPAT FOR EACH ROW
DECLARE
L_COUNT NUMBER(2);
QUANT NUMBER(10);
BEGIN
SELECT COUNT(*) INTO L_COUNT FROM STOCKPAT WHERE PRODUCTID = :NEW.PRODUCTID;
IF L_COUNT > 0 THEN
SELECT QUANTITY INTO QUANT FROM STOCKPAT WHERE PRODUCTID = :NEW.PRODUCTID;
IF  QUANT < :NEW.SALESQUANTITY THEN
raise_application_error(-20505,'You cannot sale more than what you have!');
END IF;
UPDATE STOCKPAT SET QUANTITY=QUANTITY - :NEW.SALESQUANTITY WHERE PRODUCTID=:NEW.PRODUCTID;
ELSE
--INSERT INTO STOCKPAT VALUES(:NEW.PRODUCTID, :NEW.PRODUCTNAME, :NEW.SALESQUANTITY);
raise_application_error(-20504,'There is no product with such productid');
END IF;
END;
/

INSERT INTO STOCKPAT VALUES(100, 'Mango',DEFAULT);
INSERT INTO STOCKPAT VALUES(101, 'APPLE', DEFAULT);

SELECT * FROM STOCKPAT;

INSERT INTO PURCHASEPAT VALUES(100, 1000, '25-JUL-2018', 2);
INSERT INTO PURCHASEPAT VALUES(102, 1001, '25-JUL-2018', 2);

SELECT * FROM STOCKPAT;
SELECT * FROM PURCHASEPAT;

INSERT INTO SALESPAT VALUES(100, '25-JUL-2018', 3);

SELECT * FROM SALESPAT;

INSERT INTO SALESPAT VALUES(100, '25-JUL-2018', 1);

SELECT * FROM SALESPAT;
SELECT * FROM STOCKPAT;

INSERT INTO PURCHASEPAT VALUES(102, 1003, '25-JUL-2018', 2);

INSERT INTO PURCHASEPAT VALUES(107, 1008, '25-JUL-2018', 2);



CREATE TABLE TEMPEMP(
  EMPNO NUMBER(10),
  EMPNAME VARCHAR2(100)
);

CREATE OR REPLACE TRIGGER TRIGTEMPEMP BEFORE INSERT ON TEMPEMP FOR EACH ROW
DECLARE
TEMPID NUMBER(10);
L_COUNT NUMBER(2);
BEGIN
SELECT COUNT(*) INTO L_COUNT FROM TEMPEMP WHERE EMPNO = :NEW.EMPNO;
IF (L_COUNT > 0) THEN
  RAISE_APPLICATION_ERROR('-20600', 'This empno exists!');
END IF;
END;
/

SELECT * FROM TEMPEMP;

INSERT INTO TEMPEMP VALUES(100,'bob');
INSERT INTO TEMPEMP VALUES(100,'bobee');


-- Enumerated types

create or replace type address_ty as object
(
  street varchar2(40),
  city varchar2(20)
);
/

create table persondata(empid number(5), details address_ty);

select * from persondata;

insert into persondata values(101, address_ty('mo', 'ka'));

select * from persondata;

select empid, A.details.street, A.details.city from persondata A;

-- drop type address_ty force; -- columns will be dropped where it is referenced because of force


-- Nested Tables
  
/*
Subprograms 

functions return value
procedures perform action and do not return any value. In oracle, it may or may not return value.

Advantages of subprogrmas:
extensibility
modularity
reusability and maintainability
abstraction

A procedure has 2 parts:
-specification
-body

spec (specification) contain only declarative part

In oracle, parameters can be supplied in 3 different modes:
in - parameter can just accept value
out - parameter can only return value
inout - both

DEFAULT: in

parameters in procedure statement are formal parameters.
in anonymous block they are actual parameters.

FUNCTIONS

ANYTHING IN BOX BRACKETS WHILE READING DOCUMENTATION IT DENOTES OPTIONAL

DBMS_OUTPUT is a package

*/

CREATE OR REPLACE PROCEDURE MYPROCPAT (A IN NUMBER, B IN NUMBER) IS
RES NUMBER;
BEGIN
RES := A+B;
DBMS_OUTPUT.PUT_LINE('Result is: ' || RES);
END;
/

EXECUTE MYPROCPAT(55,55);
EXEC MYPROCPAT(2,2);

CREATE OR REPLACE PROCEDURE MYPROCOUTPAT (A IN NUMBER, B IN NUMBER, C OUT NUMBER) IS
BEGIN
C:= A+B;
END;
/

VARIABLE N NUMBER;
EXEC MYPROCOUTPAT(1,1,:N);
PRINT N;
 
  
-- IF YOU HAVE DML STATEMENTS IN FUNCTION THEN CALL THEM THROUGH ANONYMOUS BLOCK ONLY

/*
package contains function1. When employee id given input then it shoould return per annum salary.
Another function, empid supplied and it hsould return manager's name.
procedure to calculate (parameter wuld be emp no.) bonus. sal < 1000 then bonus is 10%. 1000-2000 20%
2000-3000 30%
3000 and above 50%
*/

SELECT * FROM EMP;

CREATE OR REPLACE PACKAGE PATPACK AS
FUNCTION PERANNUM(EID NUMBER) RETURN NUMBER;
FUNCTION MNGRNAME(EID NUMBER) RETURN VARCHAR2;
PROCEDURE BONUS(EID NUMBER);
END PATPACK;
/

SELECT * FROM EMP;

CREATE OR REPLACE PACKAGE BODY PATPACK AS 
FUNCTION PERANNUM(EID NUMBER) RETURN NUMBER IS P_A_SAL NUMBER;
BEGIN
SELECT SAL*12 INTO P_A_SAL FROM EMP WHERE EMPNO=EID;
RETURN P_A_SAL;
END PERANNUM;

FUNCTION MNGRNAME(EID NUMBER) RETURN VARCHAR2 IS M_NAME VARCHAR(30);
BEGIN
SELECT ENAME INTO M_NAME FROM EMP WHERE EMPNO = (SELECT MGR FROM EMP WHERE EMPNO = EID);
RETURN M_NAME;
END MNGRNAME;

PROCEDURE BONUS(EID NUMBER) IS 
SAL_NO NUMBER;
BEGIN
SELECT SAL INTO SAL_NO FROM EMP WHERE EMPNO = EID;
IF SAL_NO < 1000 THEN
DBMS_OUTPUT.PUT_LINE('Your salary with bonus is : ' || TO_CHAR( SAL_NO + (SAL_NO * 0.10) ) || ' and your bonus is: ' || TO_CHAR(SAL_NO*0.10) );
ELSIF SAL_NO >= 1000 AND SAL_NO <= 2000 THEN
DBMS_OUTPUT.PUT_LINE('Your salary with bonus is : ' || TO_CHAR( SAL_NO + (SAL_NO * 0.20) ) || ' and your bonus is: ' || TO_CHAR(SAL_NO*0.20) );
ELSIF SAL_NO > 2000 AND SAL_NO <= 3000 THEN
DBMS_OUTPUT.PUT_LINE('Your salary with bonus is : ' || TO_CHAR( SAL_NO + (SAL_NO * 0.30) ) || ' and your bonus is: ' || TO_CHAR(SAL_NO*0.30) );
ELSIF SAL_NO > 3000 THEN
DBMS_OUTPUT.PUT_LINE('Your salary with bonus is : ' || TO_CHAR( SAL_NO + (SAL_NO * 0.50) ) || ' and your bonus is: ' || TO_CHAR(SAL_NO*0.50) );
END IF;

END BONUS;

END PATPACK;
/

SELECT * FROM EMP;

EXEC PATPACK.BONUS(7369);

SELECT PATPACK.MNGRNAME(7369) FROM DUAL;

-- assignment.sql --

SELECT * FROM EMP;

SELECT ENAME FROM EMP WHERE JOB LIKE 'ANALYST' OR JOB LIKE 'SALESMAN';

SELECT * FROM EMP WHERE HIREDATE < '30-SEP-1981';

SELECT ENAME,JOB FROM EMP WHERE JOB NOT LIKE 'MANAGER';

SELECT ENAME FROM EMP WHERE EMPNO=7369 OR EMPNO=7521 OR EMPNO=7839 OR EMPNO=7934 OR EMPNO=7788; 

SELECT DEPTNO,ENAME FROM EMP WHERE DEPTNO != 30 AND DEPTNO != 40 AND DEPTNO != 10; 

SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE BETWEEN '30-JUN-1981' AND '31-DEC-1981'; 

SELECT DISTINCT JOB FROM EMP;

SELECT ENAME FROM EMP WHERE COMM IS NULL;

SELECT ENAME,JOB FROM EMP WHERE MGR IS NULL;

SELECT ENAME FROM EMP WHERE DEPTNO IS NULL;

SELECT ENAME FROM EMP WHERE COMM IS NOT NULL;

SELECT ENAME FROM EMP WHERE ENAME LIKE 'S%' OR ENAME LIKE '%S';

SELECT ENAME FROM EMP WHERE ENAME LIKE '_I%';

SELECT EMPNO, ENAME FROM EMP WHERE ENAME LIKE '_i%' OR ENAME LIKE '_I%';

/* #15 */ 
SELECT EMPNO,ENAME FROM EMP WHERE ENAME NOT LIKE '%T';

SELECT MGR, EMPNO, ENAME, HIREDATE FROM EMP ORDER BY MGR ASC;

SELECT MGR, EMPNO, ENAME, HIREDATE FROM EMP ORDER BY MGR ASC, HIREDATE DESC;

SELECT * FROM EMP ORDER BY COMM ASC;

SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL LIKE '%5%';

/* #20 */
SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL LIKE '%500';

SELECT DISTINCT JOB FROM EMP;

SELECT ENAME, DEPTNO FROM EMP WHERE DEPTNO=10 OR DEPTNO=30 ORDER BY ENAME;

SELECT ENAME, JOB FROM EMP WHERE DEPTNO=20 AND SOUNDEX(JOB)=SOUNDEX('CLARK');

SELECT ENAME FROM EMP WHERE ENAME LIKE '%LL%' OR ENAME LIKE '%TH%';

/* #25: */

SELECT * FROM EMP WHERE EMPNO NOT IN (SELECT DISTINCT MGR FROM EMP WHERE MGR IS NOT NULL);

SELECT ENAME, HIREDATE FROM EMP WHERE TO_CHAR(HIREDATE, 'YYYY') = '1981';

SELECT ENAME, JOB, SAL, COMM FROM EMP WHERE JOB='SALESMAN' AND SAL > COMM ORDER BY SAL DESC, ENAME; 

SELECT ENAME || ' WORKS SINCE ' || HIREDATE || ' AS ' || JOB DESCRIPTION FROM EMP;

/* Substitution varialbe: */
DEFINE start_date = '01-JAN-1980'
DEFINE end_date = '31-DEC-1981'
--prints all substitution variables
DEFINE; 

SELECT ENAME, HIREDATE FROM EMP WHERE HIREDATE BETWEEN '&start_date' AND '&end_date';

/* #30 */

SELECT ENAME,JOB,SAL FROM EMP WHERE SAL < 1000 AND (JOB='CLERK' OR JOB='MANAGER');

SELECT ENAME, SAL*12 "ANNUAL SALARY" FROM EMP WHERE SAL*12 > 14000;

-- CASE INSENSITIVE QUERY:
SELECT * FROM EMP WHERE UPPER(ENAME) = UPPER('allen'); 

-- NOTE: CONCAT ONLY ACCEPTS 2 PARAMETERS. USE SINGLE QUOTE FOR STRING
SELECT CONCAT(CONCAT(ENAME, ' WORKS AS '), JOB) DESCRIPTION FROM EMP WHERE ENAME='SMITH';

/* #35: */
SELECT ENAME FROM EMP WHERE ENAME LIKE '__L%';

SELECT * FROM EMP WHERE GREATEST(COMM, SAL)=SAL;

SELECT ENAME, ROUND(SAL + (SAL*0.15)) "INC SAL" FROM EMP;  

SELECT EMPNO, ENAME FROM EMP WHERE EMPNO/2!=FLOOR(EMPNO/2);

SELECT COUNT(*) "No. of employees" FROM EMP;

-- #40: 

SELECT COUNT(DISTINCT JOB) "No. of designations" FROM EMP;

SELECT SUM(SAL) "Total salaries paid" FROM EMP;

SELECT MAX(SAL), MIN(SAL), AVG(SAL) FROM EMP;

SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN';

SELECT COUNT(*), AVG(SAL) FROM EMP WHERE DEPTNO=20;

-- #45:

SELECT ENAME, SAL, (SAL*0.10) PF FROM EMP;

SELECT ENAME, ABS(CAST(TO_CHAR(HIREDATE,'YYYY') AS INT) - CAST(TO_CHAR(SYSDATE, 'YYYY') AS INT)) "Years of Experience" FROM EMP WHERE ABS(CAST(TO_CHAR(HIREDATE,'YYYY')AS INT) - CAST(TO_CHAR(SYSDATE, 'YYYY') AS INT)) > 26;

SELECT * FROM EMP ORDER BY SAL;

SELECT ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC;

SELECT ENAME, SAL, SAL*0.10 PF, SAL*0.50 HRA, SAL*0.30 DA, (SAL + SAL*0.10 + SAL*0.50 + SAL*0.30) GROSS FROM EMP ORDER BY GROSS;

-- #50:
SELECT EMPNO,ENAME,MONTHS_BETWEEN(TO_DATE(SYSDATE), HIREDATE) FROM EMP WHERE MONTHS_BETWEEN(TO_DATE(SYSDATE), HIREDATE) > 200;

SELECT * FROM TAB; -- salgrade table doesn't exist

SELECT ENAME, TRIM( ' ' FROM TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'MONDAY'), 'DAY ", the " DDTH " of " MONTH ", " YYYY' )) REVIEW FROM EMP;

-- 53:

SELECT ENAME, SAL,
CASE WHEN SAL > 3000 THEN 'GOOD SALARY'
WHEN SAL <=3000 AND SAL >= 2000 THEN 'AVERAGE SALARY'
WHEN SAL <=2000 AND SAL >= 100 THEN 'POOR SALARY'
END AS "SALARY COMMENT"
FROM EMP;

-- 57:

SELECT ENAME, HIREDATE, TO_CHAR(HIREDATE, 'DY') FROM EMP WHERE TO_CHAR(HIREDATE, 'DY') = 'MON';

-- 58:

DECLARE
DOB VARCHAR2(15) := '&DOB';
DAYS NUMBER(15);
BEGIN
DBMS_OUTPUT.PUT_LINE(DOB);
SELECT ABS( TO_DATE(DOB, 'DD-MM-YYYY') - SYSDATE ) DAYS INTO DAYS FROM DUAL;
DBMS_OUTPUT.PUT_LINE('You are ' || DAYS || ' days old');
END;
/

-- 60: Not complete
DECLARE
NAME VARCHAR2(100);
COMMGIVEN NUMBER(10);
CURSOR MYCUR IS SELECT ENAME, COMM FROM EMP;
BEGIN
OPEN MYCUR;
LOOP
FETCH MYCUR INTO NAME, COMMGIVEN;
EXIT WHEN MYCUR%NOTFOUND;
IF COMMGIVEN IS NOT NULL THEN
DBMS_OUTPUT.PUT_LINE(NAME || ' ' || COMMGIVEN);
ELSE
DBMS_OUTPUT.PUT_LINE(NAME || ' No Commision');
END IF;
END LOOP;
CLOSE MYCUR;
END;
/

-- 61:
SELECT E.ENAME, E.JOB, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND D.DNAME='SALES';

-- 62:
SELECT E.ENAME, E.JOB, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND (D.DNAME='ACCOUNTING' OR D.DNAME='RESEARCH');

-- 63:
SELECT E.ENAME, E.JOB, D.DNAME, E.SAL FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND (D.DNAME='ACCOUNTING' AND E.SAL>1500);

-- 64:
SELECT E.ENAME, E.JOB, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND (D.DNAME='SALES' AND E.JOB='SALESMAN');

-- 65:
SELECT E.ENAME, E.JOB, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND D.LOC='DALLAS';

-- 66:
SELECT E.ENAME, E.JOB, D.DNAME, E.SAL FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND (D.DNAME='SALES' AND E.SAL BETWEEN 1200 AND 1700);

-- 67:
SELECT D.DEPTNO, D.DNAME FROM DEPT D WHERE NOT EXISTS ( SELECT E.DEPTNO FROM EMP E WHERE E.DEPTNO=D.DEPTNO );

-- 68: 
SELECT D.DEPTNO, COUNT(*) NUM_EMP FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO;

-- 69:
SELECT D.DEPTNO, COUNT(*) NUM_EMP FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND D.DEPTNO=&ENTER_DEPT_NO GROUP BY D.DEPTNO;

-- 70:
SELECT D.DEPTNO, COUNT(*) NUM_EMP, SUM(SAL) "Total Salaries" FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO;

-- 71:
SELECT JOB, SUM(SAL) "Total Salaries" FROM EMP GROUP BY JOB;

-- 72:
SELECT DEPTNO FROM (SELECT DEPTNO, AVG(SAL) AVG_SAL FROM EMP GROUP BY DEPTNO) WHERE AVG_SAL > 2000;

-- 73:
SELECT D.DEPTNO, COUNT(*) NUM_EMP, MAX(SAL), MIN(SAL), AVG(SAL) FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO;

-- 74:
SELECT D.DEPTNO, COUNT(*) NUM_EMP FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO;

-- 75:
SELECT D.DEPTNO, COUNT(*) NUM_EMP, SUM(SAL) "Total Salaries" FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO;

-- 76:
SELECT JOB, COUNT(*) "Number of Employees" FROM EMP GROUP BY JOB ORDER BY 2 DESC;
